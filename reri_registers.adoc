== Memory-mapped register interface

RERI defines a memory-mapped programming interface. The memory-mapped
registers of each error bank are located within a naturally aligned 4-KiB region
(a page) of physical address space.

The behavior for register accesses where the address is not aligned to
the size of the access, or if the access spans multiple registers, of if the
size of the access is not 4 bytes or 8 bytes, is `UNSPECIFIED`. The atomicity
of access to an 8 byte register is `UNSPECIFIED`. The implementation may
observe the 8 byte access as two 4 byte accesses. A 4 byte access to an IOMMU
register must be single-copy atomic.

[NOTE]
====
If an implementation may observe a 8 byte register access as two 4 byte
accesses then such implementations must preserve the semantics of the 8 byte
access and must cause any side effects only after both accesses have been
observed.
====

The RERI registers have little-endian byte order (even for systems where
all harts are big-endian-only).

[NOTE]
====
Big-endian-configured harts that make use of an IOMMU are expected to implement
the `REV8` byte-reversal instruction defined by the Zbb extension. If `REV8` is
not implemented, then endianness conversion may be implemented using a sequence
of instructions.
====

=== Register layout

.RERI error bank Memory-mapped register layout
[width=100%]
[%header, cols="^3,6,^3, 12, 10"]
|===
|Offset|Name            |Size|Description                 | Is Optional?
|0     |                |8   |                            | No
|===

=== Reset behavior
The reset value is 0 for the following registers fields.

The reset value is 0 for the following registers.

* `ipsr`

The reset value is `UNSPECIFIED` for all other registers and/or fields.

=== Register 1

.Register 1 register fields
[wavedrom, , ]
....
{reg: [
  {bits: 8, name: 'version'},
  {bits: 56, name: 'custom'},
], config:{lanes: 8, hspace:1024}}
....

[width=100%]
[%header, cols="1,2,1,5"]
|===
|Bits  |Field      |Attribute | Description
|7:0   |`version`  |RO        | The `version` field holds the version of the
                                specification implemented by the IOMMU. The low
                                nibble is used to hold the minor version of the
                                specification and the upper nibble is used to
                                hold the major version of the specification.
                                For example, an implementation that supports
                                version 1.0 of the specification reports 0x10.
|===

